from typing import Optional, Union

import great_expectations.exceptions as ge_exceptions
from great_expectations.core.id_dict import BatchSpec
from great_expectations.execution_engine.split_and_sample.data_sampler import (
    DataSampler,
)

try:
    import sqlalchemy as sa
except ImportError:
    sa = None
try:
    from sqlalchemy.sql import Selectable
    from sqlalchemy.sql.elements import BinaryExpression, BooleanClauseList
except ImportError:
    Selectable = None
    BinaryExpression = None
    BooleanClauseList = None


class SqlAlchemyDataSampler(DataSampler):
    def sample_using_limit(
        self,
        execution_engine: "SqlAlchemyExecutionEngine",
        batch_spec: BatchSpec,
        where_clause: Optional[Selectable] = None,
    ) -> Union[(str, BinaryExpression, BooleanClauseList)]:
        import inspect

        __frame = inspect.currentframe()
        __file = __frame.f_code.co_filename
        __func = __frame.f_code.co_name
        for (k, v) in __frame.f_locals.items():
            if any((var in k) for var in ("__frame", "__file", "__func")):
                continue
            print(f"<INTROSPECT> {__file}:{__func} - {k}:{v.__class__.__name__}")
        "Sample using a limit with configuration provided via the batch_spec.\n\n        Note: where_clause needs to be included at this stage since SqlAlchemy's semantics\n        for LIMIT are different than normal WHERE clauses.\n\n        Also this requires an engine to find the dialect since certain databases require\n        different handling.\n\n        Args:\n            execution_engine: Engine used to connect to the database.\n            batch_spec: Batch specification describing the batch of interest.\n            where_clause: Optional clause used in WHERE clause. Typically generated by a splitter.\n\n        Returns:\n            A query as a string or sqlalchemy object.\n        "
        if not where_clause:
            where_clause = True
        table_name: str = batch_spec["table_name"]
        dialect: str = execution_engine.engine.dialect.name.lower()
        if dialect == "oracle":
            raw_query: Selectable = (
                sa.select("*")
                .select_from(
                    sa.table(table_name, schema=batch_spec.get("schema_name", None))
                )
                .where(where_clause)
            )
            query: str = str(
                raw_query.compile(
                    execution_engine, compile_kwargs={"literal_binds": True}
                )
            )
            query += "\nAND ROWNUM <= %d" % batch_spec["sampling_kwargs"]["n"]
            return query
        elif dialect == "mssql":
            selectable_query: Selectable = (
                sa.select("*")
                .select_from(
                    sa.table(table_name, schema=batch_spec.get("schema_name", None))
                )
                .where(where_clause)
                .limit(batch_spec["sampling_kwargs"]["n"])
            )
            string_of_query: str = str(
                selectable_query.compile(
                    execution_engine.engine, compile_kwargs={"literal_binds": True}
                )
            )
            n: Union[(str, int)] = batch_spec["sampling_kwargs"]["n"]
            self._validate_mssql_limit_param(n)
            string_of_query = string_of_query.replace("?", str(n))
            return string_of_query
        else:
            return (
                sa.select("*")
                .select_from(
                    sa.table(table_name, schema=batch_spec.get("schema_name", None))
                )
                .where(where_clause)
                .limit(batch_spec["sampling_kwargs"]["n"])
            )

    def _validate_mssql_limit_param(self, n: Union[(str, int)]) -> None:
        import inspect

        __frame = inspect.currentframe()
        __file = __frame.f_code.co_filename
        __func = __frame.f_code.co_name
        for (k, v) in __frame.f_locals.items():
            if any((var in k) for var in ("__frame", "__file", "__func")):
                continue
            print(f"<INTROSPECT> {__file}:{__func} - {k}:{v.__class__.__name__}")
        "Validate that the mssql limit param is passed as an int or a string representation of an int.\n\n        Args:\n            n: mssql limit parameter.\n\n        Returns:\n            None\n        "
        if not isinstance(n, (str, int)):
            raise ge_exceptions.InvalidConfigError(
                "Please specify your sampling kwargs 'n' parameter as a string or int."
            )
        if isinstance(n, str) and (not n.isdigit()):
            raise ge_exceptions.InvalidConfigError(
                "If specifying your sampling kwargs 'n' parameter as a string please ensure it is parseable as an integer."
            )

    def sample_using_random(
        self,
        execution_engine: "SqlAlchemyExecutionEngine",
        batch_spec: BatchSpec,
        where_clause: Optional[Selectable] = None,
    ) -> Selectable:
        import inspect

        __frame = inspect.currentframe()
        __file = __frame.f_code.co_filename
        __func = __frame.f_code.co_name
        for (k, v) in __frame.f_locals.items():
            if any((var in k) for var in ("__frame", "__file", "__func")):
                continue
            print(f"<INTROSPECT> {__file}:{__func} - {k}:{v.__class__.__name__}")
        "Sample using random data with configuration provided via the batch_spec.\n\n        Note: where_clause needs to be included at this stage since we use the where clause\n        to determine the total number of rows to use in determining the rows returned in the\n        sample fraction.\n\n        Args:\n            execution_engine: Engine used to connect to the database.\n            batch_spec: Batch specification describing the batch of interest.\n            where_clause: Optional clause used in WHERE clause. Typically generated by a splitter.\n\n        Returns:\n            Sqlalchemy selectable.\n        "
        table_name: str = batch_spec["table_name"]
        num_rows: int = execution_engine.engine.execute(
            sa.select([sa.func.count()])
            .select_from(
                sa.table(table_name, schema=batch_spec.get("schema_name", None))
            )
            .where(where_clause)
        ).scalar()
        p: float = batch_spec["sampling_kwargs"]["p"] or 1.0
        sample_size: int = round(p * num_rows)
        return (
            sa.select("*")
            .select_from(
                sa.table(table_name, schema=batch_spec.get("schema_name", None))
            )
            .where(where_clause)
            .order_by(sa.func.random())
            .limit(sample_size)
        )

    def sample_using_mod(self, column_name: str, mod: int, value: int) -> bool:
        import inspect

        __frame = inspect.currentframe()
        __file = __frame.f_code.co_filename
        __func = __frame.f_code.co_name
        for (k, v) in __frame.f_locals.items():
            if any((var in k) for var in ("__frame", "__file", "__func")):
                continue
            print(f"<INTROSPECT> {__file}:{__func} - {k}:{v.__class__.__name__}")
        "Take the mod of named column, and only keep rows that match the given value"
        return (sa.column(column_name) % mod) == value

    def sample_using_a_list(self, column_name: str, value_list: list) -> bool:
        import inspect

        __frame = inspect.currentframe()
        __file = __frame.f_code.co_filename
        __func = __frame.f_code.co_name
        for (k, v) in __frame.f_locals.items():
            if any((var in k) for var in ("__frame", "__file", "__func")):
                continue
            print(f"<INTROSPECT> {__file}:{__func} - {k}:{v.__class__.__name__}")
        "Match the values in the named column against value_list, and only keep the matches"
        return sa.column(column_name).in_(value_list)

    def sample_using_md5(
        self, column_name: str, hash_digits: int = 1, hash_value: str = "f"
    ) -> bool:
        import inspect

        __frame = inspect.currentframe()
        __file = __frame.f_code.co_filename
        __func = __frame.f_code.co_name
        for (k, v) in __frame.f_locals.items():
            if any((var in k) for var in ("__frame", "__file", "__func")):
                continue
            print(f"<INTROSPECT> {__file}:{__func} - {k}:{v.__class__.__name__}")
        "Hash the values in the named column, and split on that"
        return (
            sa.func.right(
                sa.func.md5(sa.cast(sa.column(column_name), sa.Text)), hash_digits
            )
            == hash_value
        )
