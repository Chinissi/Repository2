from __future__ import annotations

import os
import zipfile
from contextlib import contextmanager
from functools import cached_property
from io import BytesIO
from pathlib import Path
from typing import TYPE_CHECKING, Generator, Optional

from docs.logging import Logger

if TYPE_CHECKING:
    from invoke.context import Context
    from packaging import version


class DocsBuilder:
    def __init__(
        self,
        context: Context,
        current_directory: Path,
    ) -> None:
        self._context = context
        self._current_directory = current_directory

    def build_docs(self) -> None:
        """Build API docs + docusaurus docs."""
        self._invoke_api_docs()

        self.logger.print_header("Building docusaurus docs...")
        self._context.run("yarn build")

    def build_docs_locally(self) -> None:
        """Serv docs locally."""
        self._invoke_api_docs()
        self.logger.print_header("Running yarn start to serve docs locally...")
        self._context.run("yarn start")

    def create_version(self, version: version.Version) -> None:
        self.logger.print_header(f"Creating version {version}")
        MIN_PYTHON_VERSION = 3.8
        MAX_PYTHON_VERSION = 3.11

        old_version_file = self._read_prior_release_version_file()
        self._write_release_version(
            "\n".join(
                [
                    "// this file is autogenerated",
                    "export default {",
                    f"  release_version: 'great_expectations, version {version}',",
                    f"   min_python: '{MIN_PYTHON_VERSION}',",
                    f"   max_python: '{MAX_PYTHON_VERSION}',",
                    "}",
                ]
            )
        )

        self._invoke_api_docs()
        self._context.run(f"yarn docusaurus docs:version {version}")

        # process the above
        os.chdir("..")  # TODO: none of this messing with current directory stuff
        os.chdir("docusaurus")
        self._write_release_version(old_version_file)

    @contextmanager
    def _load_zip(self, url: str) -> Generator[zipfile.ZipFile, None, None]:
        import requests  # imported here to avoid this getting imported before `invoke deps` finishes

        response = requests.get(url)
        zip_data = BytesIO(response.content)
        with zipfile.ZipFile(zip_data, "r") as zip_ref:
            yield zip_ref

    def _invoke_api_docs(self) -> None:
        """Invokes the invoke api-docs command.
        If this is a non-PR running on netlify, we use the latest tag. Otherwise, we use the current branch.
        """
        self.logger.print("Invoking api-docs...")

        # TODO: not this: we should do this all in python
        self._run("(cd ../../; invoke api-docs)")

    def _read_prior_release_version_file(self) -> str:
        with open(self._release_version_file) as file:
            return file.read()

    def _write_release_version(self, content: str) -> None:
        with open(self._release_version_file, "w") as file:
            file.write(content)

    def _run(self, command: str) -> Optional[str]:
        result = self._context.run(command, echo=True)
        if not result:
            return None
        elif not result.ok:
            raise Exception(f"Failed to run command: {command}")  # noqa: TRY002, TRY003
        return result.stdout.strip()

    def _run_and_get_output(self, command: str) -> str:
        output = self._run(command)
        assert output
        return output

    @property
    def _release_version_file(self) -> str:
        return "./docs/components/_data.jsx"

    @cached_property
    def logger(self) -> Logger:
        return Logger()
